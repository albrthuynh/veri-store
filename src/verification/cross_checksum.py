"""
cross_checksum.py -- Fingerprinted cross-checksum (fpcc) construction.

The fpcc is generated by the client at dispersal time and distributed to all
servers alongside their respective fragment.  It encodes both a hash commitment
(h_i = SHA-256(d_i) for each fragment) and fingerprints for the first m
fragments (phi_j = fp(r, d_j) for j in [0, m)).

Structure (Definition 3.2 from the paper):
    fpcc = {
        "hashes":       [h_0, h_1, ..., h_{n-1}],   # hex strings
        "fingerprints": [phi_0, phi_1, ..., phi_{m-1}],  # int (GF256 values)
        "r":            <int>,                        # oracle output (GF256)
        "n":            <int>,
        "m":            <int>,
    }

The value of r is stored for reference/debugging but is always recomputed from
the hashes before any verification step to prevent tampering.
"""

from __future__ import annotations
import json
from dataclasses import dataclass
from ..fingerprint.field import GF256
from ..erasure.encoder import Fragment


@dataclass
class FingerprintedCrossChecksum:
    """The fpcc data structure distributed to all servers at dispersal time.

    Attributes:
        hashes (list[bytes]):        SHA-256 digest of each fragment, in index order.
        fingerprints (list[GF256]):  fp(r, d_j) for j in [0, m), in index order.
        r (GF256):                   The evaluation point derived from the hashes.
        n (int):                     Total number of fragments.
        m (int):                     Reconstruction threshold.
    """

    hashes: list[bytes]
    fingerprints: list[GF256]
    r: GF256
    n: int
    m: int

    @classmethod
    def generate(cls, fragments: list[Fragment]) -> FingerprintedCrossChecksum:
        """Build an fpcc from a complete set of freshly encoded fragments.

        Args:
            fragments: All n Fragment objects in index order (as returned by
                       erasure.encode).

        Returns:
            A FingerprintedCrossChecksum ready for distribution.

        Raises:
            ValueError: If `fragments` is empty or not sorted by index.
        """
        # TODO: 1. Compute h_i = RandomOracle.hash_fragment(f.data) for each f.
        # TODO: 2. Derive r = RandomOracle.derive(hashes).
        # TODO: 3. Compute phi_j = fingerprint(r, fragments[j].data) for j < m.
        # TODO: 4. Return FingerprintedCrossChecksum(hashes, fingerprints, r, n, m).
        ...

    # ------------------------------------------------------------------
    # Serialization
    # ------------------------------------------------------------------

    def to_json(self) -> str:
        """Serialize the fpcc to a JSON string for storage/transmission.

        Returns:
            A JSON string encoding all fields.
        """
        # TODO: Convert bytes to hex, GF256 to int, then json.dumps.
        ...

    @classmethod
    def from_json(cls, json_str: str) -> FingerprintedCrossChecksum:
        """Deserialize an fpcc from its JSON representation.

        Args:
            json_str: A JSON string produced by to_json().

        Returns:
            A FingerprintedCrossChecksum instance.
        """
        # TODO: json.loads, convert hex -> bytes, int -> GF256.
        ...

    def digest(self) -> str:
        """Return a hex digest of the canonical JSON representation.

        Used as the fpcc_digest field in FragmentRecord to allow re-verification.

        Returns:
            A hex string (SHA-256 of the canonical JSON).
        """
        # TODO: return hashlib.sha256(self.to_json().encode()).hexdigest()
        ...
